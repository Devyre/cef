diff --git gpu/ipc/common/dxgi_helpers.cc gpu/ipc/common/dxgi_helpers.cc
index 811fb1e995ccb..d1772e48eef52 100644
--- gpu/ipc/common/dxgi_helpers.cc
+++ gpu/ipc/common/dxgi_helpers.cc
@@ -118,22 +118,22 @@ bool CopyDXGIBufferToShMem(
   Microsoft::WRL::ComPtr<ID3D11DeviceContext> device_context;
   d3d11_device->GetImmediateContext(&device_context);
 
-  Microsoft::WRL::ComPtr<IDXGIKeyedMutex> keyed_mutex;
-  hr = texture.As(&keyed_mutex);
-
-  if (FAILED(hr)) {
-    DLOG(ERROR) << "Failed to get keyed mutex. hr=" << std::hex << hr;
-    return false;
-  }
-
-  // Key equal to 0 is also used by the producer. Therefore, this keyed mutex
-  // acts purely as a regular mutex.
-  hr = keyed_mutex->AcquireSync(0, INFINITE);
-  if (FAILED(hr)) {
-    DLOG(ERROR) << "Failed to acquire keyed mutex. hr=" << std::hex << hr;
-    return false;
-  }
-  DXGIScopedReleaseKeyedMutex release_keyed_mutex(keyed_mutex, 0);
+//  Microsoft::WRL::ComPtr<IDXGIKeyedMutex> keyed_mutex;
+//  hr = texture.As(&keyed_mutex);
+//
+//  if (FAILED(hr)) {
+//    DLOG(ERROR) << "Failed to get keyed mutex. hr=" << std::hex << hr;
+//    return false;
+//  }
+//
+//  // Key equal to 0 is also used by the producer. Therefore, this keyed mutex
+//  // acts purely as a regular mutex.
+//  hr = keyed_mutex->AcquireSync(0, INFINITE);
+//  if (FAILED(hr)) {
+//    DLOG(ERROR) << "Failed to acquire keyed mutex. hr=" << std::hex << hr;
+//    return false;
+//  }
+//  DXGIScopedReleaseKeyedMutex release_keyed_mutex(keyed_mutex, 0);
 
   device_context->CopySubresourceRegion(staging_texture->Get(), 0, 0, 0, 0,
                                         texture.Get(), 0, nullptr);
diff --git gpu/ipc/common/gpu_memory_buffer_impl_dxgi.cc gpu/ipc/common/gpu_memory_buffer_impl_dxgi.cc
index 12f546291af33..305952e09232e 100644
--- gpu/ipc/common/gpu_memory_buffer_impl_dxgi.cc
+++ gpu/ipc/common/gpu_memory_buffer_impl_dxgi.cc
@@ -68,7 +68,7 @@ base::OnceClosure GpuMemoryBufferImplDXGI::AllocateForTesting(
       D3D11_BIND_SHADER_RESOURCE | D3D11_BIND_RENDER_TARGET,
       0,
       D3D11_RESOURCE_MISC_SHARED_NTHANDLE |
-          D3D11_RESOURCE_MISC_SHARED_KEYEDMUTEX};
+        D3D11_RESOURCE_MISC_SHARED};
 
   Microsoft::WRL::ComPtr<ID3D11Texture2D> d3d11_texture;
 
diff --git gpu/ipc/service/gpu_memory_buffer_factory_dxgi.cc gpu/ipc/service/gpu_memory_buffer_factory_dxgi.cc
index af8364900c814..c4c26c1e37f81 100644
--- gpu/ipc/service/gpu_memory_buffer_factory_dxgi.cc
+++ gpu/ipc/service/gpu_memory_buffer_factory_dxgi.cc
@@ -130,7 +130,7 @@ gfx::GpuMemoryBufferHandle GpuMemoryBufferFactoryDXGI::CreateGpuMemoryBuffer(
       D3D11_BIND_SHADER_RESOURCE | D3D11_BIND_RENDER_TARGET,
       0,
       D3D11_RESOURCE_MISC_SHARED_NTHANDLE |
-          D3D11_RESOURCE_MISC_SHARED_KEYEDMUTEX};
+          D3D11_RESOURCE_MISC_SHARED};
 
   Microsoft::WRL::ComPtr<ID3D11Texture2D> d3d11_texture;
 
diff --git media/capture/video/win/gpu_memory_buffer_tracker.cc media/capture/video/win/gpu_memory_buffer_tracker.cc
index 91ac2af43e9cd..4e92d302235e5 100644
--- media/capture/video/win/gpu_memory_buffer_tracker.cc
+++ media/capture/video/win/gpu_memory_buffer_tracker.cc
@@ -35,7 +35,7 @@ base::win::ScopedHandle CreateNV12Texture(ID3D11Device* d3d11_device,
       .BindFlags = D3D11_BIND_SHADER_RESOURCE | D3D11_BIND_RENDER_TARGET,
       .CPUAccessFlags = 0,
       .MiscFlags = D3D11_RESOURCE_MISC_SHARED_NTHANDLE |
-                   D3D11_RESOURCE_MISC_SHARED_KEYEDMUTEX};
+                   D3D11_RESOURCE_MISC_SHARED};
 
   Microsoft::WRL::ComPtr<ID3D11Texture2D> d3d11_texture;
 
diff --git ui/gl/direct_composition_surface_win_unittest.cc ui/gl/direct_composition_surface_win_unittest.cc
index 67ede44cc15f4..741c3dd30425f 100644
--- ui/gl/direct_composition_surface_win_unittest.cc
+++ ui/gl/direct_composition_surface_win_unittest.cc
@@ -95,7 +95,7 @@ Microsoft::WRL::ComPtr<ID3D11Texture2D> CreateNV12Texture(
   desc.SampleDesc.Count = 1;
   desc.BindFlags = 0;
   if (shared) {
-    desc.MiscFlags = D3D11_RESOURCE_MISC_SHARED_KEYEDMUTEX |
+    desc.MiscFlags = D3D11_RESOURCE_MISC_SHARED |
                      D3D11_RESOURCE_MISC_SHARED_NTHANDLE;
   }
 
diff --git ui/gl/gl_image_dxgi.cc ui/gl/gl_image_dxgi.cc
index d7c6ded6534f9..5cff9917f8473 100644
--- ui/gl/gl_image_dxgi.cc
+++ ui/gl/gl_image_dxgi.cc
@@ -23,10 +23,6 @@
 namespace gl {
 
 namespace {
-// Keys used to acquire and release the keyed mutex.  Will need to be kept in
-// sync with any other code that reads from or draws to the same DXGI handle.
-const static UINT64 KEY_BIND = 0;
-const static UINT64 KEY_RELEASE = 1;
 
 bool SupportedBindFormat(gfx::BufferFormat format) {
   switch (format) {
@@ -152,7 +148,6 @@ bool GLImageDXGI::BindTexImage(unsigned target) {
     return true;
 
   DCHECK(texture_);
-  DCHECK(keyed_mutex_);
   if (!SupportedBindFormat(buffer_format_))
     return false;
 
@@ -166,14 +161,6 @@ bool GLImageDXGI::BindTexImage(unsigned target) {
       return false;
   }
 
-  // Wait infinitely
-  HRESULT hrWait = keyed_mutex_->AcquireSync(KEY_BIND, INFINITE);
-
-  if (hrWait == WAIT_TIMEOUT || hrWait == WAIT_ABANDONED || FAILED(hrWait)) {
-    NOTREACHED();
-    return false;
-  }
-
   return eglBindTexImage(
              gl::GLSurfaceEGL::GetGLDisplayEGL()->GetHardwareDisplay(),
              surface_, EGL_BACK_BUFFER) == EGL_TRUE;
@@ -220,9 +207,19 @@ void GLImageDXGI::ReleaseTexImage(unsigned target) {
     return;
 
   DCHECK(texture_);
-  DCHECK(keyed_mutex_);
 
-  keyed_mutex_->ReleaseSync(KEY_RELEASE);
+  // Copy to the shared texture as a form of jank synchronization
+  if (staging_.Get() && texture_.Get()) {
+    Microsoft::WRL::ComPtr<ID3D11Device> d3d11_device;
+    staging_->GetDevice(&d3d11_device);
+    if (d3d11_device.Get()) {
+      Microsoft::WRL::ComPtr<ID3D11DeviceContext> d3d11_ctx;
+      d3d11_device->GetImmediateContext(&d3d11_ctx);
+      if (d3d11_ctx.Get()) {
+        d3d11_ctx->CopyResource(staging_.Get(), texture_.Get());
+      }
+    }
+  }
 
   eglReleaseTexImage(gl::GLSurfaceEGL::GetGLDisplayEGL()->GetHardwareDisplay(),
                      surface_, EGL_BACK_BUFFER);
@@ -243,15 +240,20 @@ bool GLImageDXGI::InitializeHandle(base::win::ScopedHandle handle,
     return false;
 
   if (FAILED(d3d11_device1->OpenSharedResource1(handle.Get(),
-                                                IID_PPV_ARGS(&texture_)))) {
+                                                IID_PPV_ARGS(&staging_)))) {
     return false;
   }
   D3D11_TEXTURE2D_DESC desc;
-  texture_->GetDesc(&desc);
+  staging_->GetDesc(&desc);
   if (desc.ArraySize <= level_)
     return false;
-  if (FAILED(texture_.As(&keyed_mutex_)))
+
+  desc.BindFlags = D3D11_BIND_RENDER_TARGET | D3D11_BIND_SHADER_RESOURCE;
+  desc.MiscFlags = 0;
+
+  if (FAILED(d3d11_device1->CreateTexture2D(&desc, nullptr, &texture_))) {
     return false;
+  }
 
   handle_ = std::move(handle);
   return true;
diff --git ui/gl/gl_image_dxgi.h ui/gl/gl_image_dxgi.h
index 1facae06e891c..91596e4e3c412 100644
--- ui/gl/gl_image_dxgi.h
+++ ui/gl/gl_image_dxgi.h
@@ -44,7 +44,6 @@ class GL_EXPORT GLImageDXGI : public GLImage {
   void ReleaseTexImage(unsigned target) override;
 
   const gfx::ColorSpace& color_space() const { return color_space_; }
-  Microsoft::WRL::ComPtr<IDXGIKeyedMutex> keyed_mutex() { return keyed_mutex_; }
   size_t level() const { return level_; }
   Microsoft::WRL::ComPtr<ID3D11Texture2D> texture() { return texture_; }
 
@@ -59,12 +58,12 @@ class GL_EXPORT GLImageDXGI : public GLImage {
 
   gfx::BufferFormat buffer_format_ = gfx::BufferFormat::BGRA_8888;
   base::win::ScopedHandle handle_;
-  Microsoft::WRL::ComPtr<IDXGIKeyedMutex> keyed_mutex_;
   size_t level_ = 0;
   gfx::Size size_;
   EGLSurface surface_ = nullptr;
   EGLStreamKHR stream_ = nullptr;
   Microsoft::WRL::ComPtr<ID3D11Texture2D> texture_;
+  Microsoft::WRL::ComPtr<ID3D11Texture2D> staging_;
 };
 
 // This copies to a new texture on bind.
diff --git ui/gl/gl_image_dxgi_unittest.cc ui/gl/gl_image_dxgi_unittest.cc
index 4499b93fda22e..f388966098b44 100644
--- ui/gl/gl_image_dxgi_unittest.cc
+++ ui/gl/gl_image_dxgi_unittest.cc
@@ -36,7 +36,7 @@ class GLImageDXGITestDelegate : public GLImageTestDelegateBase {
     desc.BindFlags = D3D11_BIND_SHADER_RESOURCE | D3D11_BIND_RENDER_TARGET;
     desc.CPUAccessFlags = 0;
     desc.MiscFlags = D3D11_RESOURCE_MISC_SHARED_NTHANDLE |
-                     D3D11_RESOURCE_MISC_SHARED_KEYEDMUTEX;
+                     D3D11_RESOURCE_MISC_SHARED;
 
     std::vector<unsigned char> originalData(size.width() * size.height() * 4);
     for (int x = 0; x < size.width(); ++x) {
diff --git ui/gl/swap_chain_presenter.cc ui/gl/swap_chain_presenter.cc
index 049fa2a2f5669..076ee78a12c04 100644
--- ui/gl/swap_chain_presenter.cc
+++ ui/gl/swap_chain_presenter.cc
@@ -990,7 +990,7 @@ bool SwapChainPresenter::PresentToSwapChain(ui::DCRendererLayerParams& params) {
     input_texture = image_dxgi->texture();
     input_level = image_dxgi->level();
     // Keyed mutex may not exist.
-    keyed_mutex = image_dxgi->keyed_mutex();
+    //keyed_mutex = image_dxgi->keyed_mutex();
     input_color_space = image_dxgi->color_space();
   } else if (image_d3d) {
     input_texture = image_d3d->texture();
